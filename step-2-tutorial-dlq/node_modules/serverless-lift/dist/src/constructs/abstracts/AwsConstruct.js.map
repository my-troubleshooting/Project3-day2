{
  "version": 3,
  "sources": ["../../../../src/constructs/abstracts/AwsConstruct.ts"],
  "sourcesContent": ["import { Construct as CdkConstruct } from \"constructs\";\nimport type { AwsProvider } from \"@lift/providers\";\nimport type { ConstructInterface } from \"@lift/constructs\";\n\nexport abstract class AwsConstruct extends CdkConstruct implements ConstructInterface {\n    static create<C extends AwsConstruct = AwsConstruct>(\n        this: {\n            new (scope: CdkConstruct, id: string, configuration: Record<string, unknown>, provider: AwsProvider): C;\n        },\n        provider: AwsProvider,\n        id: string,\n        configuration: Record<string, unknown>\n    ): C {\n        /**\n         * We are passing a `configuration` of type `Record<string, unknown>` to a parameter\n         * of stricter type. This is theoretically invalid.\n         *\n         * In practice however, `configuration` has been validated with the exact JSON schema\n         * of the construct. And that construct has generated the type for `configuration` based\n         * on that schema.\n         * As such, we _know_ that `configuration` has the correct type, it is just not validated\n         * by TypeScript's compiler.\n         */\n        return new this(provider.stack, id, configuration, provider);\n    }\n\n    abstract outputs?(): Record<string, () => Promise<string | undefined>>;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA,wBAA0C;AAInC,2BAAoC,4BAA2C;AAAA,SAC3E,OAIH,UACA,IACA,eACC;AAWD,WAAO,IAAI,KAAK,SAAS,OAAO,IAAI,eAAe;AAAA;AAAA;",
  "names": []
}
